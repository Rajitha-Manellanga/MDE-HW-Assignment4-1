/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.bts.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.bts.bTS.BTS;
import org.xtext.example.bts.bTS.BTSPackage;
import org.xtext.example.bts.bTS.Baggage;
import org.xtext.example.bts.bTS.Booking;
import org.xtext.example.bts.bTS.Bus;
import org.xtext.example.bts.bTS.City;
import org.xtext.example.bts.bTS.KIOSK;
import org.xtext.example.bts.bTS.OnlinePayment;
import org.xtext.example.bts.bTS.Passenger;
import org.xtext.example.bts.bTS.Payment;
import org.xtext.example.bts.bTS.Seat;
import org.xtext.example.bts.bTS.Ticket;
import org.xtext.example.bts.services.BTSGrammarAccess;

@SuppressWarnings("all")
public class BTSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BTSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BTSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BTSPackage.BTS:
				sequence_BTS(context, (BTS) semanticObject); 
				return; 
			case BTSPackage.BAGGAGE:
				sequence_Baggage(context, (Baggage) semanticObject); 
				return; 
			case BTSPackage.BOOKING:
				sequence_Booking(context, (Booking) semanticObject); 
				return; 
			case BTSPackage.BUS:
				sequence_Bus(context, (Bus) semanticObject); 
				return; 
			case BTSPackage.CITY:
				sequence_City(context, (City) semanticObject); 
				return; 
			case BTSPackage.KIOSK:
				sequence_KIOSK(context, (KIOSK) semanticObject); 
				return; 
			case BTSPackage.ONLINE_PAYMENT:
				sequence_OnlinePayment(context, (OnlinePayment) semanticObject); 
				return; 
			case BTSPackage.PASSENGER:
				sequence_Passenger(context, (Passenger) semanticObject); 
				return; 
			case BTSPackage.PAYMENT:
				sequence_Payment(context, (Payment) semanticObject); 
				return; 
			case BTSPackage.SEAT:
				sequence_Seat(context, (Seat) semanticObject); 
				return; 
			case BTSPackage.TICKET:
				sequence_Ticket(context, (Ticket) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BTS returns BTS
	 *
	 * Constraint:
	 *     elements+=Type+
	 */
	protected void sequence_BTS(ISerializationContext context, BTS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Baggage
	 *     Baggage returns Baggage
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Baggage(ISerializationContext context, Baggage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaggageAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Booking
	 *     Booking returns Booking
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Booking(ISerializationContext context, Booking semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBookingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Bus
	 *     Bus returns Bus
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Bus(ISerializationContext context, Bus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBusAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns City
	 *     City returns City
	 *
	 * Constraint:
	 *     (name=ID busstops+=Point*)
	 */
	protected void sequence_City(ISerializationContext context, City semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns KIOSK
	 *     KIOSK returns KIOSK
	 *
	 * Constraint:
	 *     (name=ID superType=[Payment|ID])
	 */
	protected void sequence_KIOSK(ISerializationContext context, KIOSK semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.KIOSK__SUPER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.KIOSK__SUPER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKIOSKAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getKIOSKAccess().getSuperTypePaymentIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(BTSPackage.Literals.KIOSK__SUPER_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns OnlinePayment
	 *     OnlinePayment returns OnlinePayment
	 *
	 * Constraint:
	 *     (name=ID superType=[Payment|ID])
	 */
	protected void sequence_OnlinePayment(ISerializationContext context, OnlinePayment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.ONLINE_PAYMENT__SUPER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.ONLINE_PAYMENT__SUPER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnlinePaymentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOnlinePaymentAccess().getSuperTypePaymentIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(BTSPackage.Literals.ONLINE_PAYMENT__SUPER_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Passenger
	 *     Passenger returns Passenger
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Passenger(ISerializationContext context, Passenger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPassengerAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Payment
	 *     Payment returns Payment
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Payment(ISerializationContext context, Payment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPaymentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Seat
	 *     Seat returns Seat
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Seat(ISerializationContext context, Seat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeatAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Ticket
	 *     Ticket returns Ticket
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Ticket(ISerializationContext context, Ticket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTSPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTSPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTicketAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
